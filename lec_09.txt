# c++20 eklemeleri
   - stateless lamda: default ctor, copyable
   - unevaluated context de lambda ifadelerinin kullanilabilmesi
   ex:
    
    main()
    {
        using gset = set<string, decltype([](const string& s1, const string& s2)
                            { return s1 > s2; })>; 
		gset set1;
	    rfill(set1, 10, rname);        
        print(set1);

        using lenset = set<string, decltype([](const string& s1, const string& s2) 
                            { return s1.length() > s2.length(); })>; 
		lenset set2;
	    rfill(set2, 5, rname);        
        print(set2);

        using absset = set<int, decltype([](int x, int y) { return abs(x) > abs(y); })>; 
		absset set3{-5, -9, -2, 6, ...};
        print(set3);

    }

# templeted lambda
    - c++20: auto yerine template syntax kullanma

## auto kullanildiginda elde edilecek dezavantajlar:
    - yazma kolayligi
    - 
   
   ex:
        auto f = [](const auto& vals) {
            // val in turu fonksiyon cagirisina gore belirlenecek
            // auto ya karsilik gelen turu ogrenmek istesek:

            // decltype vals in turunu verecek
            // ex: vector<int> -> vector<int>&
            // dolayisiyla decay_t ile refereansligi cikaracagiz
            using V = decay_t<decltype(vals)>;  // vals auto ya karsilik gelen tur

            using T = typename  V::value_type;
            T::func()
        } 


    ex: yeni syntax
        
        // avantajar
        // - bu function sadece vector<T> turunden input lar icin kullanilacak
        // - vector de kullanilan tur T yi dogrudan kullanabiliriz, type traitler gerek kalmadan

        auto f = [] <typename T>( const std::vector<T>& vals) {
            T x{};
            T::foo();
        } 

[2.avantaj]

    ex: eski syntax bazi seneryolar
    
        auto f1 = [](int x, int y) { return x + y; };   // parametre cikarimi yok

        f1(12, 34);
        f1(12, 3.4);    // double da gonderilebilir, implicit olarak int e
        donusturulecek turler
        
        auto f2 = [](auto x, auto y) { return x + y;};

        f2(1, 3.4);     // her iki parametre icin ayri ayri tur cikarimi var
                        // bu turler icin toplama gecerli degilse syntax error


        auto f2 = [](auto x, decltype(x) y) { return x + y;};

        // y icin tur cikarimi yok, x in turu y icin kulllanilacak

        f3(1.2, 8);     // iki tur de double
        f3(1,2, "alif"); // error

    ex:  c++20, templated lamda
        auto f2 = []<typename T> (T x, T y) { return x + y;};

        auto n = f4(12, 56);        // ok
        auto n = f4(5.6, 2.3);      // ok
        auto n = f4(5.6, 2.3f);     // cagiran kodun ayni turden olmasina zorluyor

    ex:
        auto f = [] <typename T, int n> ( T(&ra)[n] ) {
            for (auto& x : r)
                ++x;
        };

        int a[]{1, 4, 7, ..};
        f(a);

        for(int i : a)
            std::cout << i << " ";


    ex:
        auto f = []<typename T>(std::vector<T>& x, const T& tval)
        {
            x.push_back(tval);
        };

        vector<int> ivec;

        f(ivec, 12);    // ok
        f(ivec, 1.2);   // error


    soru:
        auto f = [](int x) { return x + 5; } 

        f(12);                          // ok
        auto val = f.operator()(12);    // ok


        auto f = []<typename T>(T x) { return x+5; };

        f<int>(12);             // not legal, f is a class type
        f.operator()<int>(16);  // legal

[perfect forwarding, yazim kolayligi]
    ex:
        auto f = [](auto&& ...args) {
            func(std::forward<decltype(args)>(args)...);
        }

    ex:
        auto f = []<typename ...Args>(Args&& ...args) {
            func(std::forward<Args>(args)...);
        }

 # lambda icinde parametre paketini capture etmek
    ex:
        delay_invoke, resme bak

    ex:
        delay invaoke, move()

        workaround:
            args.. i make_tuple ile yakala

            std::make_tuple(std::move(args)...)]() -> decltype(auto)
                return std::apply(f, tup);

     eX:
        
# lambda lar recursive olabilir mi?
-> copper spice youtube channel

# recursive lambda
    - faydadan cok dezavantaj getirebilir, std::cuntion kullanildigi icni

i   ex:
        std::function<long long int(int)> factorial = p[&](int a) {
            return a < 2 ? 1 : a * factorial(a - 1);
        };

        for(int i = 0; i < 20; ++i) {
            std::cout << i << "! = " factorial(i) << "\n";
        }

    ex:
        std::function<int(int, int)> gcd = [&](int a, int b) {
            return b == 0 ? a : gcd(b, a % b);
        };

        std::cout << gcd(40, 72);

    ex:
        int main(
        {
            const auto factorial = [](int n) {
                const auto fact_impl = [] () -> int
            };
        }



========================== Type Identity (c++20) =============================
irrelevant soru: ??

soru:
    template<typename T>
    void process(std::vector<T> x, T y, int idx);

    int main()
    {
        std::vector<int> vec{};

        process(vec, 10, 3);        // gecerli

        std::vector<string> vec2{};
        process(vec2, "neco", 3);   // gecersiz, conflicting parameters
                                    // T= string, "neco" -> const char*
    }

# oyle bir sey yapmak istiyoruz ki 2. parametre icin tur cikarimi yapilmasin

    template<typename T>
    struct TypeIdentity {
        using type = T;
    };

    template<typename T>
    using TypeIdentity_t = TypeIdentity::type;

    template<typename T>
    void process(std::vector<T> x, Typeidentity_t<T> y, int idx);

    int main()
    {

        std::vector<string> vec2{};
        process(vec2, "neco", 3);   // ok 
    }


# standard kutuphane, c++20

    ex:
        #include <type_traits>

        int main()
        {
            type_identity_t<int> x;     // x =int
            type_identity_t<double> x;  // x = double
        }

    ex:
        template<typenmae T>
        void func(std::vector<T> x, std::type_identity_t<T> y)
        {
            
        }

======================================================================
# underlying type
    enum class Nec : char {nxy, pcr, msn};  // char is underlying type

    enum class Nec : unsigned {nxy, pcr, msn};  
    underlying_type_t<Nec> x = 5;           // x is unsigned
======================================================================


===================== string view =======================================
# c++17, format kutuphanse fazlaca kullaniyor

# salt okuma amacali bir yazi alma

    In C:
        void func(const char *p)

    In C++;
        string view harici her secenegin bir dezavantaji var

        void func(const std::string& x);
            - bu fonksiyona herhangi bir yazi gecemem
                 * ya bir string nesnesi
                 * yada bir cstring kullaacagiz

            yani:
                func("nbla bla bla ");
                
                temporary materialization -> bir string nesnesi olusturulacak
                ancak bu bir ilave maliyet

        2) C deki gibi const char* kullanirsak
            -> input olarak string gonderemeyiz.
                str.cstr() kullanarak

            -> okuma amacla alacagim bu string icin herhangi bir API kullanmam

        3) overloading yapilabilir
            -> ancak bu da overkill, sirf bu amacla 

    => diger problem, yazi cstring olmak zorunda degil

        eX:
            std::Array<char, 20>    => bir yazi tutabilir
            
            std::vector<char>       => bir yazi tutabilir

# string view
    - okuma amacli bir yaziyi, habgi formda olursa olsun dusuk maliyetle alir
      (karakterler ardisik)
    - string islemleri icin bir sinif interface ine sahip


     => herhangi ardisik karakterler:

            sercansatici
              *   *
             ptr 

        string_view: yukaridaki gibi bir pointr + ardisik karakterleri, 
                     salt okuma amaciyla wrap eden bir class

## string_view ayni sekilde dizilere de uygulanabilir
   illa char ile sinirli olmak zorunda degil


# basics:

## string_view is a very light class
    - dolayisiyla string view sininfini kopyalamasi ucuz

    #include<string_view>   //header

    basic_string_view<char, ...>

    std::cout << sizeof(char*)       << "\n";    // 4
    std::cout << sizeof(string_view) << "\n";    // 8, 2 pointer 
                                                 //    yada  1 pointer + count


## interview_question***
    - dangling reference/pointer

    => string_view is a non-owning reference
        string_view nesnesi yazinin sahibi olmadigindan bu nesnenin
        hayati bitti mi, hala valid mi bunu bilemez.


## string_view nesnesi illa bir nesneye baglanmak zorunda degil

    ex:
        string_view sv;

## functions (string deki fonksiyonlar)
    at()
    []
    (c)begin
    (c)end
    back
    compare     -> returns int
    copy
    data        -> sonunda NULL char olma garantisi yok
    empty
    end
    start/ends_with     -> c_++20
    find
    find_first/last_(not)_of
    front
    npos
    =operator
    starts_with
    substr       -> string sinifinda overkill, bunun yerine string view kullan
    swap

    Butun fonksiyonlar const, except
    const olmayan 2 fonksiyon: bunlar gozlem araligini degistirir
        remove_prefix/suffix

##
    - sinifin empty fonksiyonu true gonderecek
    - ?? nullptr olacak


    std::cout << boolalpha
i             << sv.emptyh()



## nelerle initialize edebilirim
    - string
    - data ctor
    - range ctor
    - ctor

    ex:
        char str[] = "necari ...";


        string_view sv1(str);
        string_view sv2(str + 2, str + 5);
        string_view sv(str, 6);

        cout << sv.size() << "\n";
        cout << sv << "\n";     // yazinin sonunda NULL char olmak zorunda degil
        cout << sv << "\n";     // yazinin sonunda NULL char olmak zorunda degil
        cout << sv.data() << "\n";     // data() NULL char gorene kadar yazar 

    
    ex:
        array<char, 5> ar {'a', 'h', 'm', 'e', 't'};

        string_view sv{ar.data(), ar.size()};

        cout << sv << "\n";
        cout << sv.data() << "\n";  // undefined behaviour: 
                                    // data const char* dondurur ancak sonunda
                                    // NULL yok. non terminating 

    ex:
        string str{"gokhan zilanli"};
        string_view sv{ str };

        std::cout << "sv = " sv << "\n";
        cout << sv.size() << "\n";


    ex:
        string str{"gokhan zilanli"};
        string_view sv{ str.data(), 6 };

    ex:
        string str{"gokhan zilanli"};
        string_view sv{str.data() + 8, str.data() + 11};

## string view in ctor una gecece

    ex:
        void func(std::string_view sw);

        int main()
        {
            char str[]{"necati ergin"};
            func("bitcoin rises");

            string sx = {"mustafa"};
            func (sx);

            string_view sv;
            func(sv)
        }

# string_view baktigi dizinin sahibi degil

    char str[]{"necati ergin "};

    string_view sv = str;
    std::cout << "sv = " << sv << "\n";

    str[1] = 'u';
    str[3] = 'x';

    std::cout << "sv = " << sv << "\n"; // degismis yazi



# ozellikle auto ile yazilan type deduction a dikkat

ex:
    using namespace std::literals;

    auto x = "mustafa";     // x -> const char*
    auto y = "mustafa"s;    // y -> string 

    auto z = "mustafa"sv;   // z-> string_view


#i ??? burayi kaciridm
    class Person {
    public:
        std::string getname() const;
    private:
        std::string mname;
    };

    int main()
    {
        Person p;

        string_view sv = p.get_name();
    }

# geri donus degerini string_view nesnesine baglamayin
    ???


#
    ex:
        string sx{ "mustafa bakircioglu" };

        string_view sv{ sx };

        cout << sv << "\n";

        sx.assign(100, 'A');    // yazi degisti, reallocation

        cout << sv << "\n";     // dangling pointer, sv hala eski yaziyi gosterir


# 

    ex:
        void process(string_view sv)
        {
            sv.substr()     // sununla ayni: sv.substr(0, npos)
            sv.substr(15)   // sununla ayni: sv.substr(15, npos)

            // string_view degil, string.substr kullanilsa yeni bir string
            // uretilecekti.
            auto sx = sv.substr(15, 20);    // sx string view
        }


    ex:
        void process(string_view sv)
        {
            if(auto idx = sv.find(.); idx != string::npos) {
               // ... 
            }
        }

    ex:
        string sx{ "mustafa bakircioglu" };

        cout << "boolalpha" << sx.starts_with("mustafa") << "\n";   //
        cout << "boolalpha" << sx.ends_with("oglu") << "\n";        // false










































































































































































































