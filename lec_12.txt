# Templates
    -> derleyiciye kod yazdirir
    -> template => metacode

# cesitleri
    - function template
    - class template
    - alias template        (modern c++)
    - variable template     (modern c++)

    => standardlara gore "function template" ve "template function"
       diye bir terim farkliligi yok.

    => instantiation: user-code un compiler tarafindan yazilmasi
 
    => alias template: using anahtar sozucugu ile template support
            (typedef template support etmiyordu)

    => variable template: template keyword lere bagli kod yazdirma

# ex from STL:
    function template:
        - algorithm headerindaki fonksiyonlar
        - numeric headerindak algoritma fonksiyonlar
        
    class template:
        - containerlar 
            * sequence (vector, list, forward_list, string, array) 
            * assocoative (set, map, multiset, multimap) 
            * unordered associative (unordered set/map/multiset/multimap)

        - stack, queue, priority queue
            * bir container alip bunlarin interface ini adapte eder

        - smart pointers
            * unique ptr, shared ptr, 

        - RAII amacli guard siniflari

        - hash sinif sablonu

        - metafonksiyon olarak kullanilan siniflar
            * type_traits dosyasindaki class lar
                -> compile time programlamasi icin veri uretirler

    alias template:
        - sonu "_t" ile biten fonksiyonlar 

          ex:
            remove_reference_t<int &>

        => template icinde kullanidiginda typename anahtar sozcugunun 
           kullanilma zorunlulugunu ortadan kaldirir

            ex:
                template<typename T>
                using RemoveReference_t = typename std::remove_reference<T>::type

    variable template:
        - sonu "_v" ile biten fonksiyonlar

          ex:
            is_rvalue_reference_v<int&&>

          implementation:
            template<typename T>
            inline constexpr bool is_RvalueReferenc_v = std::is_rvalue_reference<T>::value;

========== reminder: inline variable ======================
int x = 10; // global variable, violates one definition rule if in the header 

=> similar for functions

// ali.h
inline void func(int x) { ... }

=? linker bu func dan sadece 1 tane gorur, ODR ihlal edilmez

=> token-by-token ayni fonksiyonlar inline ??? 

    usefull for ???

==========
# c++17 inline for variables 
    => ayni sekilde optimizasyona yonelik degil

    ex:
        inline int x = 10;

    => token by token ayni olmasi durumunda birden fazla dosyada include edilse
       bile 1 tane degisken olusturulur.
       ODR ihlal edilmez
============================================================

# template parameters:

    template<typename T>
    void func(T x, T y)
    {
        // x,y are call parameters
        // T template parameter
    }

# categories of template parameters:
    - type parameter
    - non-type parameter
    - template template parameter

## type parameter
    class, typename keywords

    ex: template<class T>   // class keyword u kotu bir tercihdi

    ex: template<typename T> void func(T x) { ... }

## non-type parameter

    template<int n>

    - ex: std::array, bitset

    ex:
        template<typename T, size_t n>
        struct Array{
            T a[n];
        };

    ex:
        template<size_t n>
        class Bitset{...}

        std::bitset<16>

    => Non-type parametre nin hangi turlerden olabilecegi her versiyonda genisletildi
        - tam sayi turler

        - pointer tur

        - template<int(*p)(int)>

        - member function pointer
          ex:
            class Myclass {
            public:
                int foo(int);
            };

            template<int (Myclass::*p)(int)>
            class Neco {

            };

        - gercek sayi turu (c++20)

            template<double x>
            class Myclass {};

            Myclass<2.3> x;
        
        - constexpr ctor a sahip sinif turleri (c++20)

        - non-type auto parameter (c++14)

            template<auto n>
            class Myclass {};

            Myclass<14>
            Myclass<20U>
            Myclass<3.4>    (c++20)

example:
        - template<typename T, T n>
          class Myclass {};

          * T type parameter
          * n non-type parameter

        => integral constant type
           - cok sik, basit ama metafunction sinifinda asil destegi veren sinif

integral constant implementation:

    template<class T, T v>
    struct integral_constant;

    template<class T, T v>
    struct integral_constatn {
        static constexpr T value = v;
        using value_type = T;
        using type = integral_constant; // using injected-class-name
        constexpr operator value_type() const noexcept { return value }; 
        constexpr value_type operator()() const noexcept { return value; } // C++14
    };

## template template parameter 
    => eskiden class anahtar sozcugu zorunluydu, simdi typename kullanilabilir

    ex:
        template<template <typename , typename > class X>
        void func


    ex:
        template<typename T>
        class Myclass {};

        template<typename T, template<typename> typename X>
        void func(T x, X<T>)
        {
            // ...
        }


    ex:

        template<template<typename> typename X>
        class Nec{
        public:
            Nec()
            {
                std::cout << typeid(X<int>).name() << "\n";
            }

        };

        int main()
        {
            Nec<Myclass> x;
        }

    ex:

        template<typename T, template<typename> typename X>
        class Nec{
        public:
            Nec()
            {
                std::cout << typeid(X<T>).name() << "\n";
            }

        };

        int main()
        {
            Nec<int, Myclass> x;
        }

    ex:
        template<typename T, typename A, template<typename, typename> class Con>
        void func(Con<T, A> &x)
        {
            // input vector olabilir 
        }

    ex:

        template<typenmae T>
        class Myclass{};

        template<typename T, template<typename> class Con>
        void func(Con<T> x)
        {
            // input vector olabilir 
        }


        int main()
        {
            func<int, Myclass>
        }

======================== 
# derleyicinin kod yazabilmesi icin parametreleri compile-time da bilmesi gerekir
  peki derleyici bunu nasil bilecek?

    => 3 temel arac var:
        1) template argument deduction
            - fonksiyon sablonlari
            - class templates, CTAD: (C++17)

            ex:
                int x = 10, y = 34;
                swap(x, y);     // context den anliyor

            ex:
                vector x = {1, 2, 3, 5};
                vector<int> x = {1, 2, 3, 5};   // buradan vector type i anliyor

                vector y = {x, x};  // vector<vector<int>>

            ex:
                optional x = 5;

            ex:
                pair p = {12, 6};
                pair p2 = {2.3, 3.4f};

            ex:
                template<typename T, size_t n>
                void func(T(&)[n])

                int a[10]{};
                func(a);

            ex:
                template<typename T, typename U>
                void func(T(*p)(U))
                {
                    cout << typeid(T).name() << "\n";
                    cout << typeid(U).name() << "\n";
                }


                int foo(double) { return 1 };

                int main()
                {
                    func(foo);      // decay to function pointer
                                    // T -> int, U -> double
                }

            ex:
                template<typename T, typename U>
                void func(T(Myclass::*)(U))
                {
                    cout << typeid(T).name() << "\n";
                    cout << typeid(U).name() << "\n";
                }


                class Myclass{
                public:
                    int foo(long) { return 1; }
                } 

                int main()
                {
                    func(&Myclass::foo);    // decay to function pointer
                                            // T -> int, U -> long
                }
                

        2) explicit template argument 
            - template parametresini user verir

            ex:
                template<typename T, typename U>
                void func(T, U)
                {
                    
                }

                int main()
                {
                    func<int, double>(12, 2.3)
                }

            - bazi template lerde deduction sansi yok, bu durumda explicit cok onemli
           
                ex: 
                    template<typename T, typenmae ...Types>
                    std::unique_ptr<t> MakeUnique(Types && ...args)
                    {
                        return std::unique_ptr<T>{new T{std::forward<Types>(args)...}};
                    }

                    make_unique<int>(12);   // deduction sansi yok
                
                ex:
                   template<typenmae T, typenmae U>
                   void func(T x, U y)
                   {...}

                   func<int>('A', 4.5);
                
                ex:
                   template<int x, int y>
                   void func()
                   {...}

                   func<10, 20>();

        3) default template parameter 
            - c++11 sonrasi fonksiyonlarda kullanilma hakki geldi

            ex:
                template<typename T, typename U = int>
                class Myclass{};

                int main()
                {
                    Myclass<std::string>
                    Myclass<int, double>
                }

           ex:
            - container siniflar

            vector<int> -> vector<int, std::allocator<int>>;

            template<typenmae K, typenmae Comp = less<K>, typenmae A = allocator<K>>
            class ...

          ex:

            template<typename T>
            struct DefaultDelete {
                operator()(T *p)
                {
                    delete p;
                }
            };

            template<typename T, typename D = std::default_delete<T>>
            class UniquePtr {
            public:
                ~UniquePtr()
                {
                    D{}(mp);    // aslinda delete eden deleter
                }

            private:
                T* mp;
            };

        ex:
            - ostream sinif

            basic_ostream<char> => basic_ostream<char, ...>

            string => basic_string<char, char_traits<char>, allocator<char>>

## default template parameter alan argumanin sagindaki butun parametreler default arg almak zorunda

=====================
# ??? 

  ex:
    template<typename T, typename U>
    void func(Tx, U, y);

    void(*fp)(int, double) = &func;

# template argument deduction icin derleyici 2 fazda kontrol yapar
    1. parametreler eslestirilmeden bir sytax check yapilir:
        - parameter-independent isim arama, parantez vs.
    
    2. derleyici t

        
# auto ile template type deduction arasinda 1 istisna harici hic bir fark yok

    template<typename T>
    void func(T x) {}

    int main()
    {
        // kurallar ayni, bir istisna harici
        auto x = expr;
        func(expr)
    }

## template typename deduction rules:
    1. call parametresinin referans declaraotoru icermemesi
    2. call parametresinin referans declaraotoru icermesi
    3. call parametre forwarwding referans

##1
    - const luk ve referanslik kaybedilir  kaybedilir

        ex:
            template<typenmae T>
            void func(T x);

            const int x = 10;
            const int& z = 10;

            func(x);    // T = int

            ???

    - array decay olur

        int a[10]{}
        func(a);        // T = int*, (dizi turu degil)

        const int b[10]{};
        func(b)         // T = const int*, low-level constluk dusmez


    - string literal -> const char*

        func("ali");    // T= const char*, array decay
        
        func("ali");    // T= const char*, array decay

        
        int foo(int);
        func(foo);      // T = int(*)(int), function -> function pointer


    => Ayni template tur parametresi kullanan birden fazla parametre varsa bunlar ayni olmak zorunda

        ex:
            template<typenmae T>
            void func(T x, T y)

            func(1, 4.5);   // ambiguity
            func('A', 120);   // ambiguity


## 2. referans    

    template<typename T>
    void func(T &x);

    deduction yapildiginda
    - ???

        ex:
            func(12);   // error, sol taraf PR valuie ya baglanamz

    - const luk dusmez
        ex:
            template<typename T>
            void func(T &x)
            {
                ???
            }

            const int x = 10;
            func(x);            // error


    - array to pointer conversion olmaz (array decay yok):

        ex:
            int a[3]{};
            func(a);            // T= int[3], decay yok

            derleyicinin yazacagi kod

            void func(???)

        ex:

            template<typename T>
            void func(T &x)
            {
                T y{};  // T = int[3]

                std::cout << typeid(y).name() << "\n";
            }


        ex:
            const int a[] = {1, 2, 3};
            func(a);    // T = const int[3]

    
    - function -> function referans

        ex:
            template<typename T>
            void func(T &x)
            {
                T y{};  // T = int[3]

                std::cout << typeid(y).name() << "\n";
            }

            int bar(int);

            func(bar);

            derleyici sunu yazacakti

            ???
        
        soru:
            func("alican"); // T = const char[7]    

        
        error ex:
            template<typename T>
            void func(T &x, T& y)
            {
            }


            func("alican", "ab");   // ambiguity, int[7] vs int[3] 

       ex:
            int a[5]{};
            int a[7]{};

  ##3, forwarding referans
    - ne olursan ol ben seni alirim

        ex:
            template<typename T>
            void func(T&& x);

            int main()
            {

            }

    - derleyicinin yazdigi fonksiyonun parametre degiskeni mutlaka referans olacak
        *L-val yada R-val referans

    - fonksiona R-val referans gonderilirse

        func(10);       // T= int


    - fonksiona L-val referans gonderilirse

        int ival{10};
        func(ival);     // T = int& ???


    - Reference collapsing rules

    => tabiki perfec-forwarding olmak zorunda degil


###
    template<typename T>
    void func(T&& x, T y)
    {
        
    }

    int main()
    {
        int a = 10;

        func(a);    // T = int&

        func(a, a); // ambiguity: T= int&, T = int
    }

    ex:

    template<typename T>
    void func(T&& x, const std::vector<T>& vec)
    {
        
    }

    int main()
    {
        vector<int> ivec(10);
        func(ivec[0], ivec);    //ambig, T = int& vs T = int    ???
    }

# tur cikarimini bloke etme
    - type identity
    - yada 2. bir tur kullan

    ex:
    # include <type_traits>

    template<typename T>
    void func(T x, std::add_lvalue_reference<T> y)
    {
       // 2.parametre birinci parametrenin turunden elde edilecek 
    }


=============================
# function overloading:
  explicit specialization (full specialization)
  partial specialization (sinif sablonlari)


## soru:
    
    void func(int);
    void func(int); // redeclaration

    int func(int);  // syntax error

#
    template<typename T>
    void func(T x)
    {

    }



    ??? buraya bak






